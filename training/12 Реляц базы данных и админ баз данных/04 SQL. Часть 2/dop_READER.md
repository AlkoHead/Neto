### Задание 1

Одним запросом получите информацию о магазине, в котором обслуживается более 300 покупателей, и выведите в результат следующую информацию: 
- фамилия и имя сотрудника из этого магазина;
- город нахождения магазина;
- количество пользователей, закреплённых в этом магазине.
```sql
-- Выбираем данные для отчета:
SELECT 
    -- Объединяем имя и фамилию сотрудника с пробелом между ними
    CONCAT(s.first_name, ' ', s.last_name) AS 'Сотрудник магазина',
    
    -- Название города, где находится магазин
    c.city AS 'Город нахождения магазина',
    
    -- Считаем количество уникальных покупателей
    COUNT(customer_id) AS 'Количество покупателей'

-- Основная таблица - информация о сотрудниках
FROM 
    staff s

-- Соединяем с таблицей магазинов по общему полю store_id
-- USING используется когда имена столбцов идентичны в обеих таблицах
JOIN 
    store st USING(store_id)

-- Соединяем с таблицей покупателей по полю store_id
-- (покупатели привязаны к магазинам)
JOIN 
    customer cu USING(store_id)

-- Соединяем с таблицей адресов по address_id сотрудника
-- (чтобы узнать где находится магазин сотрудника)
JOIN 
    address a ON s.address_id = a.address_id

-- Соединяем с таблицей городов по city_id из адреса
JOIN 
    city c ON a.city_id = c.city_id

-- Группируем результаты по:
-- - ID сотрудника
-- - Имени сотрудника
-- - Фамилии сотрудника
-- - Городу магазина
-- (Это необходимо для корректной работы функции COUNT)
GROUP BY 
    s.staff_id, s.first_name, s.last_name, c.city

-- Фильтруем результаты, оставляя только тех сотрудников,
-- у которых количество покупателей больше 300
HAVING 
    COUNT(customer_id) > 300;
```

Пояснения:  
1. Использовал USING вместо ON для соединения таблиц по одинаковым именам столбцов (более читаемо)  
2. алиас для city использовал просто c для краткости  
3. Добавил все неагрегированные столбцы в GROUP BY (это требуется стандартом SQL)  


### Задание 2

Получите количество фильмов, продолжительность которых больше средней продолжительности всех фильмов.
```sql
SELECT COUNT(*) AS films_count_above_average
FROM film
WHERE length > (SELECT AVG(length) FROM film);
```

Пояснение:  
1. Вложенный запрос (SELECT AVG(length) FROM film) вычисляет среднюю  продолжительность всех фильмов  
2. Основной запрос подсчитывает (COUNT(*)) количество фильмов, у которых продолжительность (length) больше этого среднего значения  

Альтернативный вариант с выводом дополнительной информации:  
```sql
SELECT 
    COUNT(*) AS films_count_above_average,
    AVG(length) AS average_length,
    MIN(length) AS min_length,
    MAX(length) AS max_length
FROM 
    film
WHERE 
    length > (SELECT AVG(length) FROM film);
```

Получения списка фильмов:  
```sql
SELECT film_id, title, length
FROM film
WHERE length > (SELECT AVG(length) FROM film)
ORDER BY length DESC;
```


### Задание 3

Получите информацию, за какой месяц была получена наибольшая сумма платежей, и добавьте информацию по количеству аренд за этот месяц.
```sql
SELECT 
    DATE_FORMAT(p.payment_date, '%Y-%m') AS payment_month,
    SUM(p.amount) AS total_amount,
    COUNT(DISTINCT p.rental_id) AS rental_count
FROM 
    payment p
GROUP BY 
    DATE_FORMAT(p.payment_date, '%Y-%m')
ORDER BY 
    total_amount DESC
LIMIT 1;
```

Пояснение:  
1. DATE_FORMAT(p.payment_date, '%Y-%m') - выделяем год и месяц из даты платежа  
2. SUM(p.amount) - вычисляем общую сумму платежей за месяц
3. COUNT(DISTINCT p.rental_id) - подсчитываем уникальные аренды (чтобы избежать дубликатов)  
4. Группируем по месяцам и сортируем по убыванию суммы платежей  

## Дополнительные задания (со звёздочкой*)
Эти задания дополнительные, то есть не обязательные к выполнению, и никак не повлияют на получение вами зачёта по этому домашнему заданию. Вы можете их выполнить, если хотите глубже шире разобраться в материале.


### Задание 4*

Посчитайте количество продаж, выполненных каждым продавцом. Добавьте вычисляемую колонку «Премия». Если количество продаж превышает 8000, то значение в колонке будет «Да», иначе должно быть значение «Нет».
```sql
SELECT 
    staff_id AS st,                -- 1. Выбираем ID продавца (с алиасом 'st')
    COUNT(*) AS pr,               -- 2. Считаем общее количество продаж (с алиасом 'pr')
    CASE                          -- 3. Начинаем условное выражение для премии
        WHEN COUNT(*) > 8000 THEN 'Да'  -- 4. Если продаж > 8000 → "Да"
        ELSE 'Нет'                -- 5. Иначе → "Нет"
    END AS 'Премия'              -- 6. Называем колонку 'Премия'
FROM 
    rental                      -- 7. Данные берем из таблицы аренд (rental)
GROUP BY 
    staff_id;                   -- 8. Группируем результаты по ID продавца
```

Пояснения:  
1. **staff_id AS st**
- Выбираем столбец **staff_id** (идентификатор продавца)
- Переименовываем его в **st** для краткости вывода.
2. **COUNT(*) AS pr**  
- Считаем общее количество записей (продаж) для каждого продавца.
- **COUNT(*)** учитывает все строки, включая NULL-значения (если бы они были).
- Результат называем **pr** ("продажи").
3. **CASE**
- Начало условного оператора для вычисления колонки премии.
4. **WHEN COUNT(*) > 8000 THEN 'Да'**
- Если количество продаж (COUNT(*)) у продавца превышает 8000,
- В колонке "Премия" появится значение "Да".
5. **ELSE 'Нет'**
- Если продаж ≤ 8000, в колонке будет "Нет".
6. **END AS 'Премия'**
- Завершение оператора CASE.
- Итоговая колонка получает название "Премия".
7. **FROM rental**
- Запрос берет данные из таблицы **rental** (информация об арендах/продажах).
8. **GROUP BY staff_id**
- Группировка результатов по ID продавца.
- Именно благодаря **GROUP BY** агрегатные функции (**COUNT**, **CASE**) применяются к каждому продавцу отдельно.


### Задание 5*

Найдите фильмы, которые ни разу не брали в аренду.  

```sql
-- Основной запрос: выбираем фильмы, которых нет в инвентаре
SELECT 
    -- Выбираем название фильма (поле title из таблицы film)
    f.title AS 'Фильм'
FROM 
    -- Основная таблица - все фильмы (film)
    film f
-- Используем LEFT JOIN для соединения с таблицей инвентаря
LEFT JOIN 
    -- Таблица инвентаря (inventory) - какие фильмы есть в наличии
    inventory i ON f.film_id = i.film_id
-- Условие: оставляем только записи, где нет соответствия в inventory
WHERE 
    i.film_id IS NULL;
```
Пояснения: 
1. **SELECT f.title AS 'Фильм'**
- Выбираем только название фильма (без количества аренд, так как оно всегда NULL в этом случае)  
2. **FROM film f**
- Берем данные из таблицы всех фильмов (**film**), назначаем ей алиас **f**
3. **LEFT JOIN inventory i ON f.film_id = i.film_id**
- Присоединяем таблицу инвентаря (**inventory**) по ID фильма
- **LEFT JOIN** гарантирует, что все фильмы из таблицы **film** останутся в результате, даже если их нет в **inventory**
4. **WHERE i.film_id IS NULL**
- Фильтруем результаты, оставляя только записи:
> - Где не нашлось соответствия в таблице **inventory**
> - То есть фильмы, которых нет в инвентаре

Альтернативный вариант с **NOT EXISTS**
```sql
SELECT 
    f.title AS 'Фильм',
    -- Явно указываем 0 аренд для найденных фильмов
    0 AS 'Аренды'
FROM 
    film f
WHERE 
    -- Условие: фильм отсутствует в инвентаре
    NOT EXISTS (
        -- Подзапрос: ищем хотя бы одну запись в inventory с таким film_id
        SELECT 1 
        FROM inventory i 
        WHERE i.film_id = f.film_id
    );
```
Отличия:  
- **NOT EXISTS** обычно работает эффективнее для таких случаев
- Явное указание **0** вместо **NULL** делает результат понятнее
- Подзапрос проверяет существование хотя бы одной записи в inventory  